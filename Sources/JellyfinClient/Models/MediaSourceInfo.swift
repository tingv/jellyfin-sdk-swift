//
// MediaSourceInfo.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct MediaSourceInfo: Codable, Hashable {

    public var _protocol: MediaProtocol?
    public var id: String?
    public var path: String?
    public var encoderPath: String?
    public var encoderProtocol: MediaProtocol?
    public var type: MediaSourceType?
    public var container: String?
    public var size: Int64?
    public var name: String?
    /** Differentiate internet url vs local network. */
    public var isRemote: Bool?
    public var eTag: String?
    public var runTimeTicks: Int64?
    public var readAtNativeFramerate: Bool?
    public var ignoreDts: Bool?
    public var ignoreIndex: Bool?
    public var genPtsInput: Bool?
    public var supportsTranscoding: Bool?
    public var supportsDirectStream: Bool?
    public var supportsDirectPlay: Bool?
    public var isInfiniteStream: Bool?
    public var requiresOpening: Bool?
    public var openToken: String?
    public var requiresClosing: Bool?
    public var liveStreamId: String?
    public var bufferMs: Int?
    public var requiresLooping: Bool?
    public var supportsProbing: Bool?
    public var videoType: VideoType?
    public var isoType: IsoType?
    public var video3DFormat: Video3DFormat?
    public var mediaStreams: [MediaStream]?
    public var mediaAttachments: [MediaAttachment]?
    public var formats: [String]?
    public var bitrate: Int?
    public var timestamp: TransportStreamTimestamp?
    public var requiredHttpHeaders: [String: String]?
    public var transcodingUrl: String?
    public var transcodingSubProtocol: String?
    public var transcodingContainer: String?
    public var analyzeDurationMs: Int?
    public var defaultAudioStreamIndex: Int?
    public var defaultSubtitleStreamIndex: Int?

    public init(_protocol: MediaProtocol? = nil, id: String? = nil, path: String? = nil, encoderPath: String? = nil, encoderProtocol: MediaProtocol? = nil, type: MediaSourceType? = nil, container: String? = nil, size: Int64? = nil, name: String? = nil, isRemote: Bool? = nil, eTag: String? = nil, runTimeTicks: Int64? = nil, readAtNativeFramerate: Bool? = nil, ignoreDts: Bool? = nil, ignoreIndex: Bool? = nil, genPtsInput: Bool? = nil, supportsTranscoding: Bool? = nil, supportsDirectStream: Bool? = nil, supportsDirectPlay: Bool? = nil, isInfiniteStream: Bool? = nil, requiresOpening: Bool? = nil, openToken: String? = nil, requiresClosing: Bool? = nil, liveStreamId: String? = nil, bufferMs: Int? = nil, requiresLooping: Bool? = nil, supportsProbing: Bool? = nil, videoType: VideoType? = nil, isoType: IsoType? = nil, video3DFormat: Video3DFormat? = nil, mediaStreams: [MediaStream]? = nil, mediaAttachments: [MediaAttachment]? = nil, formats: [String]? = nil, bitrate: Int? = nil, timestamp: TransportStreamTimestamp? = nil, requiredHttpHeaders: [String: String]? = nil, transcodingUrl: String? = nil, transcodingSubProtocol: String? = nil, transcodingContainer: String? = nil, analyzeDurationMs: Int? = nil, defaultAudioStreamIndex: Int? = nil, defaultSubtitleStreamIndex: Int? = nil) {
        self._protocol = _protocol
        self.id = id
        self.path = path
        self.encoderPath = encoderPath
        self.encoderProtocol = encoderProtocol
        self.type = type
        self.container = container
        self.size = size
        self.name = name
        self.isRemote = isRemote
        self.eTag = eTag
        self.runTimeTicks = runTimeTicks
        self.readAtNativeFramerate = readAtNativeFramerate
        self.ignoreDts = ignoreDts
        self.ignoreIndex = ignoreIndex
        self.genPtsInput = genPtsInput
        self.supportsTranscoding = supportsTranscoding
        self.supportsDirectStream = supportsDirectStream
        self.supportsDirectPlay = supportsDirectPlay
        self.isInfiniteStream = isInfiniteStream
        self.requiresOpening = requiresOpening
        self.openToken = openToken
        self.requiresClosing = requiresClosing
        self.liveStreamId = liveStreamId
        self.bufferMs = bufferMs
        self.requiresLooping = requiresLooping
        self.supportsProbing = supportsProbing
        self.videoType = videoType
        self.isoType = isoType
        self.video3DFormat = video3DFormat
        self.mediaStreams = mediaStreams
        self.mediaAttachments = mediaAttachments
        self.formats = formats
        self.bitrate = bitrate
        self.timestamp = timestamp
        self.requiredHttpHeaders = requiredHttpHeaders
        self.transcodingUrl = transcodingUrl
        self.transcodingSubProtocol = transcodingSubProtocol
        self.transcodingContainer = transcodingContainer
        self.analyzeDurationMs = analyzeDurationMs
        self.defaultAudioStreamIndex = defaultAudioStreamIndex
        self.defaultSubtitleStreamIndex = defaultSubtitleStreamIndex
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case _protocol = "Protocol"
        case id = "Id"
        case path = "Path"
        case encoderPath = "EncoderPath"
        case encoderProtocol = "EncoderProtocol"
        case type = "Type"
        case container = "Container"
        case size = "Size"
        case name = "Name"
        case isRemote = "IsRemote"
        case eTag = "ETag"
        case runTimeTicks = "RunTimeTicks"
        case readAtNativeFramerate = "ReadAtNativeFramerate"
        case ignoreDts = "IgnoreDts"
        case ignoreIndex = "IgnoreIndex"
        case genPtsInput = "GenPtsInput"
        case supportsTranscoding = "SupportsTranscoding"
        case supportsDirectStream = "SupportsDirectStream"
        case supportsDirectPlay = "SupportsDirectPlay"
        case isInfiniteStream = "IsInfiniteStream"
        case requiresOpening = "RequiresOpening"
        case openToken = "OpenToken"
        case requiresClosing = "RequiresClosing"
        case liveStreamId = "LiveStreamId"
        case bufferMs = "BufferMs"
        case requiresLooping = "RequiresLooping"
        case supportsProbing = "SupportsProbing"
        case videoType = "VideoType"
        case isoType = "IsoType"
        case video3DFormat = "Video3DFormat"
        case mediaStreams = "MediaStreams"
        case mediaAttachments = "MediaAttachments"
        case formats = "Formats"
        case bitrate = "Bitrate"
        case timestamp = "Timestamp"
        case requiredHttpHeaders = "RequiredHttpHeaders"
        case transcodingUrl = "TranscodingUrl"
        case transcodingSubProtocol = "TranscodingSubProtocol"
        case transcodingContainer = "TranscodingContainer"
        case analyzeDurationMs = "AnalyzeDurationMs"
        case defaultAudioStreamIndex = "DefaultAudioStreamIndex"
        case defaultSubtitleStreamIndex = "DefaultSubtitleStreamIndex"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var encoderContainer = encoder.container(keyedBy: CodingKeys.self)
        try encoderContainer.encodeIfPresent(_protocol, forKey: ._protocol)
        try encoderContainer.encodeIfPresent(id, forKey: .id)
        try encoderContainer.encodeIfPresent(path, forKey: .path)
        try encoderContainer.encodeIfPresent(encoderPath, forKey: .encoderPath)
        try encoderContainer.encodeIfPresent(encoderProtocol, forKey: .encoderProtocol)
        try encoderContainer.encodeIfPresent(type, forKey: .type)
        try encoderContainer.encodeIfPresent(container, forKey: .container)
        try encoderContainer.encodeIfPresent(size, forKey: .size)
        try encoderContainer.encodeIfPresent(name, forKey: .name)
        try encoderContainer.encodeIfPresent(isRemote, forKey: .isRemote)
        try encoderContainer.encodeIfPresent(eTag, forKey: .eTag)
        try encoderContainer.encodeIfPresent(runTimeTicks, forKey: .runTimeTicks)
        try encoderContainer.encodeIfPresent(readAtNativeFramerate, forKey: .readAtNativeFramerate)
        try encoderContainer.encodeIfPresent(ignoreDts, forKey: .ignoreDts)
        try encoderContainer.encodeIfPresent(ignoreIndex, forKey: .ignoreIndex)
        try encoderContainer.encodeIfPresent(genPtsInput, forKey: .genPtsInput)
        try encoderContainer.encodeIfPresent(supportsTranscoding, forKey: .supportsTranscoding)
        try encoderContainer.encodeIfPresent(supportsDirectStream, forKey: .supportsDirectStream)
        try encoderContainer.encodeIfPresent(supportsDirectPlay, forKey: .supportsDirectPlay)
        try encoderContainer.encodeIfPresent(isInfiniteStream, forKey: .isInfiniteStream)
        try encoderContainer.encodeIfPresent(requiresOpening, forKey: .requiresOpening)
        try encoderContainer.encodeIfPresent(openToken, forKey: .openToken)
        try encoderContainer.encodeIfPresent(requiresClosing, forKey: .requiresClosing)
        try encoderContainer.encodeIfPresent(liveStreamId, forKey: .liveStreamId)
        try encoderContainer.encodeIfPresent(bufferMs, forKey: .bufferMs)
        try encoderContainer.encodeIfPresent(requiresLooping, forKey: .requiresLooping)
        try encoderContainer.encodeIfPresent(supportsProbing, forKey: .supportsProbing)
        try encoderContainer.encodeIfPresent(videoType, forKey: .videoType)
        try encoderContainer.encodeIfPresent(isoType, forKey: .isoType)
        try encoderContainer.encodeIfPresent(video3DFormat, forKey: .video3DFormat)
        try encoderContainer.encodeIfPresent(mediaStreams, forKey: .mediaStreams)
        try encoderContainer.encodeIfPresent(mediaAttachments, forKey: .mediaAttachments)
        try encoderContainer.encodeIfPresent(formats, forKey: .formats)
        try encoderContainer.encodeIfPresent(bitrate, forKey: .bitrate)
        try encoderContainer.encodeIfPresent(timestamp, forKey: .timestamp)
        try encoderContainer.encodeIfPresent(requiredHttpHeaders, forKey: .requiredHttpHeaders)
        try encoderContainer.encodeIfPresent(transcodingUrl, forKey: .transcodingUrl)
        try encoderContainer.encodeIfPresent(transcodingSubProtocol, forKey: .transcodingSubProtocol)
        try encoderContainer.encodeIfPresent(transcodingContainer, forKey: .transcodingContainer)
        try encoderContainer.encodeIfPresent(analyzeDurationMs, forKey: .analyzeDurationMs)
        try encoderContainer.encodeIfPresent(defaultAudioStreamIndex, forKey: .defaultAudioStreamIndex)
        try encoderContainer.encodeIfPresent(defaultSubtitleStreamIndex, forKey: .defaultSubtitleStreamIndex)
    }
}

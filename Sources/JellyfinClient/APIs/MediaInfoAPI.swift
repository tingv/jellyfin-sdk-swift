//
// MediaInfoAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import AnyCodable
import Foundation
import PromiseKit

open class MediaInfoAPI {
    /**
     Closes a media source.
     
     - parameter liveStreamId: (query) The livestream id. 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<Void>
     */
    open class func closeLiveStream( liveStreamId: String, apiResponseQueue: DispatchQueue = JellyfinClient.apiResponseQueue) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        closeLiveStreamWithRequestBuilder(liveStreamId: liveStreamId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Closes a media source.
     - POST /LiveStreams/Close
     - API Key:
       - type: apiKey X-Emby-Authorization 
       - name: CustomAuthentication
     - parameter liveStreamId: (query) The livestream id. 
     - returns: RequestBuilder<Void> 
     */
    open class func closeLiveStreamWithRequestBuilder(liveStreamId: String) -> RequestBuilder<Void> {
        let urlPath = "/LiveStreams/Close"
        let URLString = JellyfinClient.basePath + urlPath
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "liveStreamId": liveStreamId.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinClient.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Tests the network with a request with the size of the bitrate.
     
     - parameter size: (query) The bitrate. Defaults to 102400. (optional, default to 102400)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<URL>
     */
    open class func getBitrateTestBytes( size: Int? = nil, apiResponseQueue: DispatchQueue = JellyfinClient.apiResponseQueue) -> Promise<URL> {
        let deferred = Promise<URL>.pending()
        getBitrateTestBytesWithRequestBuilder(size: size).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Tests the network with a request with the size of the bitrate.
     - GET /Playback/BitrateTest
     - API Key:
       - type: apiKey X-Emby-Authorization 
       - name: CustomAuthentication
     - parameter size: (query) The bitrate. Defaults to 102400. (optional, default to 102400)
     - returns: RequestBuilder<URL> 
     */
    open class func getBitrateTestBytesWithRequestBuilder(size: Int? = nil) -> RequestBuilder<URL> {
        let urlPath = "/Playback/BitrateTest"
        let URLString = JellyfinClient.basePath + urlPath
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "size": size?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<URL>.Type = JellyfinClient.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Gets live playback media info for an item.
     
     - parameter itemId: (path) The item id. 
     - parameter userId: (query) The user id. 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<PlaybackInfoResponse>
     */
    open class func getPlaybackInfo( itemId: String,  userId: String, apiResponseQueue: DispatchQueue = JellyfinClient.apiResponseQueue) -> Promise<PlaybackInfoResponse> {
        let deferred = Promise<PlaybackInfoResponse>.pending()
        getPlaybackInfoWithRequestBuilder(itemId: itemId, userId: userId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Gets live playback media info for an item.
     - GET /Items/{itemId}/PlaybackInfo
     - API Key:
       - type: apiKey X-Emby-Authorization 
       - name: CustomAuthentication
     - parameter itemId: (path) The item id. 
     - parameter userId: (query) The user id. 
     - returns: RequestBuilder<PlaybackInfoResponse> 
     */
    open class func getPlaybackInfoWithRequestBuilder(itemId: String, userId: String) -> RequestBuilder<PlaybackInfoResponse> {
        var urlPath = "/Items/{itemId}/PlaybackInfo"
        let itemIdPreEscape = "\(APIHelper.mapValueToPathItem(itemId))"
        let itemIdPostEscape = itemIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        urlPath = urlPath.replacingOccurrences(of: "{itemId}", with: itemIdPostEscape, options: .literal, range: nil)
        let URLString = JellyfinClient.basePath + urlPath
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "userId": userId.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<PlaybackInfoResponse>.Type = JellyfinClient.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Gets live playback media info for an item.
     
     - parameter itemId: (path) The item id. 
     - parameter userId: (query) The user id. (optional)
     - parameter maxStreamingBitrate: (query) The maximum streaming bitrate. (optional)
     - parameter startTimeTicks: (query) The start time in ticks. (optional)
     - parameter audioStreamIndex: (query) The audio stream index. (optional)
     - parameter subtitleStreamIndex: (query) The subtitle stream index. (optional)
     - parameter maxAudioChannels: (query) The maximum number of audio channels. (optional)
     - parameter mediaSourceId: (query) The media source id. (optional)
     - parameter liveStreamId: (query) The livestream id. (optional)
     - parameter autoOpenLiveStream: (query) Whether to auto open the livestream. (optional)
     - parameter enableDirectPlay: (query) Whether to enable direct play. Default: true. (optional)
     - parameter enableDirectStream: (query) Whether to enable direct stream. Default: true. (optional)
     - parameter enableTranscoding: (query) Whether to enable transcoding. Default: true. (optional)
     - parameter allowVideoStreamCopy: (query) Whether to allow to copy the video stream. Default: true. (optional)
     - parameter allowAudioStreamCopy: (query) Whether to allow to copy the audio stream. Default: true. (optional)
     - parameter playbackInfoDto: (body) The playback info. (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<PlaybackInfoResponse>
     */
    open class func getPostedPlaybackInfo( itemId: String,  userId: String? = nil,  maxStreamingBitrate: Int? = nil,  startTimeTicks: Int64? = nil,  audioStreamIndex: Int? = nil,  subtitleStreamIndex: Int? = nil,  maxAudioChannels: Int? = nil,  mediaSourceId: String? = nil,  liveStreamId: String? = nil,  autoOpenLiveStream: Bool? = nil,  enableDirectPlay: Bool? = nil,  enableDirectStream: Bool? = nil,  enableTranscoding: Bool? = nil,  allowVideoStreamCopy: Bool? = nil,  allowAudioStreamCopy: Bool? = nil,  playbackInfoDto: PlaybackInfoDto? = nil, apiResponseQueue: DispatchQueue = JellyfinClient.apiResponseQueue) -> Promise<PlaybackInfoResponse> {
        let deferred = Promise<PlaybackInfoResponse>.pending()
        getPostedPlaybackInfoWithRequestBuilder(itemId: itemId, userId: userId, maxStreamingBitrate: maxStreamingBitrate, startTimeTicks: startTimeTicks, audioStreamIndex: audioStreamIndex, subtitleStreamIndex: subtitleStreamIndex, maxAudioChannels: maxAudioChannels, mediaSourceId: mediaSourceId, liveStreamId: liveStreamId, autoOpenLiveStream: autoOpenLiveStream, enableDirectPlay: enableDirectPlay, enableDirectStream: enableDirectStream, enableTranscoding: enableTranscoding, allowVideoStreamCopy: allowVideoStreamCopy, allowAudioStreamCopy: allowAudioStreamCopy, playbackInfoDto: playbackInfoDto).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Gets live playback media info for an item.
     - POST /Items/{itemId}/PlaybackInfo
     - For backwards compatibility parameters can be sent via Query or Body, with Query having higher precedence.  Query parameters are obsolete.
     - API Key:
       - type: apiKey X-Emby-Authorization 
       - name: CustomAuthentication
     - parameter itemId: (path) The item id. 
     - parameter userId: (query) The user id. (optional)
     - parameter maxStreamingBitrate: (query) The maximum streaming bitrate. (optional)
     - parameter startTimeTicks: (query) The start time in ticks. (optional)
     - parameter audioStreamIndex: (query) The audio stream index. (optional)
     - parameter subtitleStreamIndex: (query) The subtitle stream index. (optional)
     - parameter maxAudioChannels: (query) The maximum number of audio channels. (optional)
     - parameter mediaSourceId: (query) The media source id. (optional)
     - parameter liveStreamId: (query) The livestream id. (optional)
     - parameter autoOpenLiveStream: (query) Whether to auto open the livestream. (optional)
     - parameter enableDirectPlay: (query) Whether to enable direct play. Default: true. (optional)
     - parameter enableDirectStream: (query) Whether to enable direct stream. Default: true. (optional)
     - parameter enableTranscoding: (query) Whether to enable transcoding. Default: true. (optional)
     - parameter allowVideoStreamCopy: (query) Whether to allow to copy the video stream. Default: true. (optional)
     - parameter allowAudioStreamCopy: (query) Whether to allow to copy the audio stream. Default: true. (optional)
     - parameter playbackInfoDto: (body) The playback info. (optional)
     - returns: RequestBuilder<PlaybackInfoResponse> 
     */
    open class func getPostedPlaybackInfoWithRequestBuilder(itemId: String, userId: String? = nil, maxStreamingBitrate: Int? = nil, startTimeTicks: Int64? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, maxAudioChannels: Int? = nil, mediaSourceId: String? = nil, liveStreamId: String? = nil, autoOpenLiveStream: Bool? = nil, enableDirectPlay: Bool? = nil, enableDirectStream: Bool? = nil, enableTranscoding: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, playbackInfoDto: PlaybackInfoDto? = nil) -> RequestBuilder<PlaybackInfoResponse> {
        var urlPath = "/Items/{itemId}/PlaybackInfo"
        let itemIdPreEscape = "\(APIHelper.mapValueToPathItem(itemId))"
        let itemIdPostEscape = itemIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        urlPath = urlPath.replacingOccurrences(of: "{itemId}", with: itemIdPostEscape, options: .literal, range: nil)
        let URLString = JellyfinClient.basePath + urlPath
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: playbackInfoDto)

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "userId": userId?.encodeToJSON(),
            "maxStreamingBitrate": maxStreamingBitrate?.encodeToJSON(),
            "startTimeTicks": startTimeTicks?.encodeToJSON(),
            "audioStreamIndex": audioStreamIndex?.encodeToJSON(),
            "subtitleStreamIndex": subtitleStreamIndex?.encodeToJSON(),
            "maxAudioChannels": maxAudioChannels?.encodeToJSON(),
            "mediaSourceId": mediaSourceId?.encodeToJSON(),
            "liveStreamId": liveStreamId?.encodeToJSON(),
            "autoOpenLiveStream": autoOpenLiveStream?.encodeToJSON(),
            "enableDirectPlay": enableDirectPlay?.encodeToJSON(),
            "enableDirectStream": enableDirectStream?.encodeToJSON(),
            "enableTranscoding": enableTranscoding?.encodeToJSON(),
            "allowVideoStreamCopy": allowVideoStreamCopy?.encodeToJSON(),
            "allowAudioStreamCopy": allowAudioStreamCopy?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<PlaybackInfoResponse>.Type = JellyfinClient.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Opens a media source.
     
     - parameter openToken: (query) The open token. (optional)
     - parameter userId: (query) The user id. (optional)
     - parameter playSessionId: (query) The play session id. (optional)
     - parameter maxStreamingBitrate: (query) The maximum streaming bitrate. (optional)
     - parameter startTimeTicks: (query) The start time in ticks. (optional)
     - parameter audioStreamIndex: (query) The audio stream index. (optional)
     - parameter subtitleStreamIndex: (query) The subtitle stream index. (optional)
     - parameter maxAudioChannels: (query) The maximum number of audio channels. (optional)
     - parameter itemId: (query) The item id. (optional)
     - parameter enableDirectPlay: (query) Whether to enable direct play. Default: true. (optional)
     - parameter enableDirectStream: (query) Whether to enable direct stream. Default: true. (optional)
     - parameter openLiveStreamDto: (body) The open live stream dto. (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<LiveStreamResponse>
     */
    open class func openLiveStream( openToken: String? = nil,  userId: String? = nil,  playSessionId: String? = nil,  maxStreamingBitrate: Int? = nil,  startTimeTicks: Int64? = nil,  audioStreamIndex: Int? = nil,  subtitleStreamIndex: Int? = nil,  maxAudioChannels: Int? = nil,  itemId: String? = nil,  enableDirectPlay: Bool? = nil,  enableDirectStream: Bool? = nil,  openLiveStreamDto: OpenLiveStreamDto? = nil, apiResponseQueue: DispatchQueue = JellyfinClient.apiResponseQueue) -> Promise<LiveStreamResponse> {
        let deferred = Promise<LiveStreamResponse>.pending()
        openLiveStreamWithRequestBuilder(openToken: openToken, userId: userId, playSessionId: playSessionId, maxStreamingBitrate: maxStreamingBitrate, startTimeTicks: startTimeTicks, audioStreamIndex: audioStreamIndex, subtitleStreamIndex: subtitleStreamIndex, maxAudioChannels: maxAudioChannels, itemId: itemId, enableDirectPlay: enableDirectPlay, enableDirectStream: enableDirectStream, openLiveStreamDto: openLiveStreamDto).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Opens a media source.
     - POST /LiveStreams/Open
     - API Key:
       - type: apiKey X-Emby-Authorization 
       - name: CustomAuthentication
     - parameter openToken: (query) The open token. (optional)
     - parameter userId: (query) The user id. (optional)
     - parameter playSessionId: (query) The play session id. (optional)
     - parameter maxStreamingBitrate: (query) The maximum streaming bitrate. (optional)
     - parameter startTimeTicks: (query) The start time in ticks. (optional)
     - parameter audioStreamIndex: (query) The audio stream index. (optional)
     - parameter subtitleStreamIndex: (query) The subtitle stream index. (optional)
     - parameter maxAudioChannels: (query) The maximum number of audio channels. (optional)
     - parameter itemId: (query) The item id. (optional)
     - parameter enableDirectPlay: (query) Whether to enable direct play. Default: true. (optional)
     - parameter enableDirectStream: (query) Whether to enable direct stream. Default: true. (optional)
     - parameter openLiveStreamDto: (body) The open live stream dto. (optional)
     - returns: RequestBuilder<LiveStreamResponse> 
     */
    open class func openLiveStreamWithRequestBuilder(openToken: String? = nil, userId: String? = nil, playSessionId: String? = nil, maxStreamingBitrate: Int? = nil, startTimeTicks: Int64? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, maxAudioChannels: Int? = nil, itemId: String? = nil, enableDirectPlay: Bool? = nil, enableDirectStream: Bool? = nil, openLiveStreamDto: OpenLiveStreamDto? = nil) -> RequestBuilder<LiveStreamResponse> {
        let urlPath = "/LiveStreams/Open"
        let URLString = JellyfinClient.basePath + urlPath
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: openLiveStreamDto)

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "openToken": openToken?.encodeToJSON(),
            "userId": userId?.encodeToJSON(),
            "playSessionId": playSessionId?.encodeToJSON(),
            "maxStreamingBitrate": maxStreamingBitrate?.encodeToJSON(),
            "startTimeTicks": startTimeTicks?.encodeToJSON(),
            "audioStreamIndex": audioStreamIndex?.encodeToJSON(),
            "subtitleStreamIndex": subtitleStreamIndex?.encodeToJSON(),
            "maxAudioChannels": maxAudioChannels?.encodeToJSON(),
            "itemId": itemId?.encodeToJSON(),
            "enableDirectPlay": enableDirectPlay?.encodeToJSON(),
            "enableDirectStream": enableDirectStream?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<LiveStreamResponse>.Type = JellyfinClient.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

}
